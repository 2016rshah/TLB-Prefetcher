#include "cache.h"
#include "delta.h"
#include "champsim.h"
#include "block.h"
#include <vector>

uint64_t S = 2;
Delta delta(S);

void CACHE::tlb_prefetcher_initialize() 
{

}

PACKET make_packet(uint32_t cpu, uint64_t pf_addr) {
   PACKET pf_packet;
   pf_packet.fill_level = FILL_STLB;
   pf_packet.cpu = cpu;
   pf_packet.address = pf_addr >> LOG2_BLOCK_SIZE;
   pf_packet.full_addr = pf_addr;
   pf_packet.ip = 0; // prefetch gets dummy ip of zero
   pf_packet.type = PREFETCH;
   pf_packet.event_cycle = current_core_cycle[cpu]; // ?
   return pf_packet;
}

// this is the trigger for a prefetcher
void CACHE::tlb_prefetcher_operate(uint32_t cpu, uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type)
{
	std::vector<uint64_t> predicted = delta.find_prefetch_addrs(addr);
	uint64_t instr_id = 0; // set instruction id to zero because only used for debugging 
	for (uint64_t prediction : predicted) {
	  PACKET packet = make_packet(cpu, prediction);
	  uint32_t set = get_set(packet.address);
	  int way = check_hit(&packet);
	  
	  if(way != -1) {
	    continue;
	  }
	  uint64_t pa = va_to_pa(cpu, instr_id, packet.full_addr, packet.address);

	  way = find_victim(cpu, instr_id, set, block[set], 0, packet.full_addr, PREFETCH);
	  fill_cache(set, way, &packet);
	}
}

// when a requested line is filled (may cause eviction)  
void CACHE::tlb_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr)
{

}

void CACHE::tlb_prefetcher_final_stats()
{

}
